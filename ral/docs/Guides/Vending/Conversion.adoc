## Vending Machine Tutorial: From CAOS To RAL

// DIRECTION: Start dissecting the parts of the converted Talking Lemon.

Converting code from CAOS to RAL can be a relatively simple process or a relatively weird process.

When we left off, our CAOS code looked like this:

```
include::../AboutCAOS/TalkingLemonCTHead.cos[]
include::../AboutCAOS/TalkingLemonScriptFinal.cos[]
include::../AboutCAOS/TalkingLemonCTFooter.cos[]
```

A very literal transliteration to RAL goes as follows:

```
include::../../../samples/talking-lemon-caos-final-naive.ral[]
```

So far, this code is clearly worse than what we started with.
However, this is the most straightforward translation from CAOS to RAL.

The first concepts we have to learn when translating to RAL are:

* RAL requires explicit sections for each script, and scripts start and end with `{}`.
** This will make sense shortly.
* RAL requires you to explicitly name the classifiers of scripts.
** This will make a lot more sense shortly.
* You can write a CAOS command inline by prefixing it with `&'` and ending with `';`.
* You need to explicitly reserve any variable you wish to use.
** This part will get easier shortly.

### Fields, Variables, And Conditions

RAL has it's own syntax for fields, variables, and conditions.

This syntax completely removes the need to manually allocate VA slots, and helps with OV slots.

```
/*
field TYPE CLASS.NAME SLOT;
The 0 here indicates ov00.
*/
field int TalkingLemon.line 0;

script TalkingLemon 1 {
	&'lock';
	// RAL automatically assigns the variable number.
	let str text;
	// if (CONDITION) STATEMENT [else STATEMENT]
	if (ownr.line == 0) {
		// Assignment: EXPRESSION = EXPRESSION;
		text = "Hello! I'm a talking lemon!";
		// Field access: EXPRESSION.FIELD
		ownr.line = 2;
		&'wait 15';
		ownr.line = 1;
	} else if (ownr.line == 1) {
		text = "Oh no, not again...";
		ownr.line = 2;
		&'wait 15';
		ownr.line = 0;
	} else {
		text = "You ought not to see this...";
		ownr.line = 0;
	}
	&'rtar 1 2 10';
	// The same {} wrapping that helps with literal strings is also able to translate variable names into the variables they represent.
	&'mesg wrt+ targ 126 {text} ownr 0';
}
```

### foreach

The remove script can be improved as well.

`foreach` is the RAL equivalent to `enum`.

It still puts the result in `targ`, but it allows for the `break;` statement (leaving the loop early).

```
remove {
	// Delete all talking lemons
	// foreach (TYPE in enum[ EXPRESSION, EXPRESSION, EXPRESSION]) STATEMENT
	// foreach (TYPE in esee[ EXPRESSION, EXPRESSION, EXPRESSION]) STATEMENT
	// foreach (TYPE in etch[ EXPRESSION, EXPRESSION, EXPRESSION]) STATEMENT
	// foreach (TYPE in epas[ EXPRESSION, EXPRESSION, EXPRESSION]) STATEMENT
	// foreach (TYPE in econ EXPRESSION) STATEMENT
	foreach (TalkingLemon in enum) {
		&'kill targ';
	}
	// Remove the script
	&'scrx 2 24 8802 1';
}
```

### The RAL Standard Library

The RAL Standard Library contains RAL definitions for many CAOS commands and expressions.

As such, finishing the conversion, the result is much cleaner.

```
include::../../../samples/talking-lemon-caos-final-finished.ral[]
```

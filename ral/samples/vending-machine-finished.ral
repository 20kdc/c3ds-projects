include "vending-machine-common.ral";

AVAR_PRODUCTS = 0;
PRODUCT_COUNT = 7;

PRODUCT_KIND_NONE = 0;
PRODUCT_KIND_LEMON = 1;
PRODUCT_KIND_NUT = 2;

macro productType(int &id) avar(ownr!VendingMachine, AVAR_PRODUCTS + id)!int;

macro (int x, int y) getProductLocation(int id) {
	x = 8 + ((id & 1) * 20);
	y = id * 14;
}

macro () newRandomProductAt(int id) {
	// Decide which product we get, store it, and make the part
	let product = rand(PRODUCT_KIND_LEMON, PRODUCT_KIND_NUT);
	productType(id) = product;
	let x, y = getProductLocation(id);
	if product == PRODUCT_KIND_LEMON
		patDull(VMP_PRODUCTS + id, "ds lemon pod", 30, x, y, VMR_PRODUCT);
	else
		patDull(VMP_PRODUCTS + id, "justanut pod", 19, x, y, VMR_PRODUCT);
}

script VendingMachine:init {
	inst();
	// Set attributes
	perm(100);
	attr(ATTR_PHYSICS | ATTR_COLLIDE | ATTR_PNTR_PICKUP | ATTR_AGNT_PICKUP);
	aero(10);
	accg(2);
	fric(100);
	elas(0);
	// Set regen timer
	tick(100);
	// Prepare parts
	patDull(VMP_FRONTPLATE, VMS_GALLERY, VMS_FRONTPLATE, 0, 0, VMR_FRONTPLATE);
	for i = 0; i < 3; i++; {
		let pId = VMP_LEMON + i;
		part(pId);
		patButt(pId, VMS_GALLERY, VMS_RED_LEMON + i, 4, 0, 0, VMR_BUTTONS, [0], VendingMachine:buttonLemon + i, true);
		// Having a continuously looping animation fixes the pose when hover returns.
		anim([3, 255]);
	}
	for i = 0; i < PRODUCT_COUNT; i++; {
		newRandomProductAt(i);
	}
}

script VendingMachine:timer {
	inst();
	let id = rand(0, PRODUCT_COUNT - 1);
	if productType(id) == PRODUCT_KIND_NONE {
		newRandomProductAt(id);
	}
}

script VendingMachine:dispenseProduct {
	alias productToDrop = _p1_!int;
	lock();
	if productToDrop == -1 {
		// we've failed, nope sound
		sndc("beep");
	} else if productType(productToDrop) == PRODUCT_KIND_NONE {
		// we've still failed, nope sound
		// we can't do this in the same clause as above,
		//  as that sitll causes the read of productType.
		// productType(-1) produces a very spicy exception.
		sndc("beep");
	} else {
		sndc("lock");
		// animation of dropping product
		// start by nudging down/right
		let pX, pY = getProductLocation(productToDrop);
		for i = 0; i < 8; i++; {
			pX += 1;
			pY += 1;
			patMove(VMP_PRODUCTS + productToDrop, pX, pY);
			wait(1);
			inst();
		}
		// now let it 'fall' and hit bottom
		pY += 1;
		let velY = 0;
		while pY < 100 {
			patMove(VMP_PRODUCTS + productToDrop, pX, pY);
			wait(1);
			inst();
			velY += 1;
			pY += velY;
		}
		pY = 100;
		// push right
		while pX < 64 {
			pX += 4;
			patMove(VMP_PRODUCTS + productToDrop, pX, pY);
			wait(1);
			inst();
		}
		// finally...
		inst();
		// spawn in world product
		let myX, myY = posx(), posy();
		if productType(productToDrop) == PRODUCT_KIND_LEMON {
			dsLemonNew();
			mvsf(myX + 16, myY + 36);
			dsLemonFinish();
		} else {
			dsJustanutNew();
			mvsf(myX + 8, myY + 36);
			dsJustanutFinish();
		}
		// revert targ and virtual product goes bye-bye
		targ = ownr;
		patKill(VMP_PRODUCTS + productToDrop);
		productType(productToDrop) = PRODUCT_KIND_NONE;
	}
}

macro () dispenseProductOfKind(int kind) {
	inst();
	let productToDrop = -1;
	for i = 0; i < PRODUCT_COUNT; i++; {
		if productType(i) == kind {
			productToDrop = i;
			break;
		}
	}
	callIndirect(VendingMachine:dispenseProduct, productToDrop, 0);
}

script VendingMachine:buttonLemon {
	dispenseProductOfKind(PRODUCT_KIND_LEMON);
}

script VendingMachine:buttonJustanut {
	dispenseProductOfKind(PRODUCT_KIND_NUT);
}

script VendingMachine:buttonRandom {
	inst();
	// try random a few times
	let int productToDrop;
	for i = 0; i < 8; i++; {
		productToDrop = rand(0, PRODUCT_COUNT - 1);
		if productType(productToDrop) != PRODUCT_KIND_NONE
			break;
	}
	// if that fails then try first available
	if productType(productToDrop) == PRODUCT_KIND_NONE {
		for i = 0; i < PRODUCT_COUNT; i++; {
			if productType(i) != PRODUCT_KIND_NONE {
				productToDrop = i;
				break;
			}
		}
	}
	callIndirect(VendingMachine:dispenseProduct, productToDrop, 0);
}

